/**
 * Copyright 2020-2021 Shawn Anastasio.
 *
 * This file is part of retrec.
 *
 * retrec is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * retrec is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with retrec.  If not, see <https://www.gnu.org/licenses/>.
 */

#pragma once

#include <util/util.h>
#include <util/magic.h>
#include <arch/ppc64le/codegen/register_allocator.h>

#include <type_traits>

namespace retrec {
namespace ppc64le {

template <typename TargetTraits>
struct TargetABIMapping {
    static_assert(std::is_same_v<TargetTraits, TargetTraits>, "Unimplemented TargetABIMapping for this target!");
};

template <typename TargetTraits>
struct ABIRetrec {
    static_assert(std::is_same_v<TargetTraits, TargetTraits>, "Unimplemented ABIRetrec for this target!");
};

//
// X86_64 Targets
//

struct TargetTraitsX86_64 {
    using RegisterT = llir::X86_64Register;
};

/**
 * Mappings between the SysV X86_64 ABI and the ppc64le retrec ABI
 */
template <>
struct TargetABIMapping<TargetTraitsX86_64> {
    struct gpr_mapping {
        llir::X86_64Register target;
        llir::PPC64Register host;
    };

    /**
     * Mapping of x86_64 registers to fixed host registers.
     * These attempt to match the X86_64 SysV calling conventions to ppc64le ELFv2
     * calling conventions to reduce the save/restore penalty when performing native
     * function calls from translated code.
     */
    static constexpr gpr_mapping fixed_regs[] = {
        // SysV volatile registers
        { llir::X86_64Register::RSP, llir::PPC64Register::R1 },
        { llir::X86_64Register::RDI, llir::PPC64Register::R3 },
        { llir::X86_64Register::RSI, llir::PPC64Register::R4 },
        { llir::X86_64Register::RDX, llir::PPC64Register::R5 },
        { llir::X86_64Register::RCX, llir::PPC64Register::R6 },
        { llir::X86_64Register::R8,  llir::PPC64Register::R7 },
        { llir::X86_64Register::R9,  llir::PPC64Register::R8 },
        { llir::X86_64Register::RAX, llir::PPC64Register::R9 },

        // SysV non-volatile registers
        { llir::X86_64Register::R10, llir::PPC64Register::R23 },
        { llir::X86_64Register::R11, llir::PPC64Register::R24 },
        { llir::X86_64Register::R12, llir::PPC64Register::R25 },
        { llir::X86_64Register::R13, llir::PPC64Register::R26 },
        { llir::X86_64Register::R14, llir::PPC64Register::R27 },
        { llir::X86_64Register::R15, llir::PPC64Register::R28 },
        { llir::X86_64Register::RBX, llir::PPC64Register::R29 },
        { llir::X86_64Register::RBP, llir::PPC64Register::R30 },
    };
};

/**
 * The ABI used by code generated by retrec for X86_64 targets
 */
template<>
struct ABIRetrec<TargetTraitsX86_64> {
    using RegisterT = llir::PPC64Register;

    // Registers used by retrec functions that must be preserved by foreign function calls
    static constexpr llir::PPC64Register non_volatile_regs[] = {
        // GPRs
        llir::PPC64Register::R0,  /* Non-volatile scratch */
        llir::PPC64Register::R1,  /* SP */
        llir::PPC64Register::R3,  /* Fixed */
        llir::PPC64Register::R4,  /* Fixed */
        llir::PPC64Register::R5,  /* Fixed */
        llir::PPC64Register::R6,  /* Fixed */
        llir::PPC64Register::R7,  /* Fixed */
        llir::PPC64Register::R8,  /* Fixed */
        llir::PPC64Register::R9,  /* Fixed */
        llir::PPC64Register::R11, /* runtime_ctx ptr */
        llir::PPC64Register::R13, /* thread ptr */
        llir::PPC64Register::R14, /* lazy flag */
        llir::PPC64Register::R15, /* lazy flag */
        llir::PPC64Register::R16, /* lazy flag */
        llir::PPC64Register::R17, /* lazy flag */
        llir::PPC64Register::R23, /* Fixed */
        llir::PPC64Register::R24, /* Fixed */
        llir::PPC64Register::R25, /* Fixed */
        llir::PPC64Register::R26, /* Fixed */
        llir::PPC64Register::R27, /* Fixed */
        llir::PPC64Register::R28, /* Fixed */
        llir::PPC64Register::R29, /* Fixed */
        llir::PPC64Register::R30, /* Fixed */
        /**
         * All other GPRs are reserved for the register allocator may be clobbered
         * by foreign function calls
         */

        // Special
        llir::PPC64Register::CR,
    };

    // Registers used by retrec functions to store parameters for foreign function calls
    static constexpr llir::PPC64Register argument_regs[] = {
        // Arbitrarily chosen registers that aren't listed in non_volatile_regs
        llir::PPC64Register::R2,
        llir::PPC64Register::R10,
        llir::PPC64Register::R18,
        llir::PPC64Register::R19,
    };

    //
    // GPR aliases
    //
    static constexpr gpr_t GPR_SP = 1;
    static constexpr gpr_t GPR_FIXED_RUNTIME_CTX = 11;
    static constexpr gpr_t GPR_FIXED_FLAG_OP1 = 14;
    static constexpr gpr_t GPR_FIXED_FLAG_OP2 = 15;
    static constexpr gpr_t GPR_FIXED_FLAG_RES = 16;
    static constexpr gpr_t GPR_FIXED_FLAG_OP_TYPE = 17;
};

//
// Native ABI and helpers
//

/**
 * The ppc64le native ABI - ELFv2
 */
struct ABIElfV2 {
    using RegisterT = llir::PPC64Register;

    // Registers that ELFv2 functions won't clobber
    static constexpr llir::PPC64Register non_volatile_regs[] = {
        // GPRs
        llir::PPC64Register::R1,  /* SP */
        llir::PPC64Register::R2,  /* TOC */
        llir::PPC64Register::R13, /* Thread Pointer */
        llir::PPC64Register::R14, /* Local Variable */
        llir::PPC64Register::R15, /* Local Variable */
        llir::PPC64Register::R16, /* Local Variable */
        llir::PPC64Register::R17, /* Local Variable */
        llir::PPC64Register::R18, /* Local Variable */
        llir::PPC64Register::R19, /* Local Variable */
        llir::PPC64Register::R20, /* Local Variable */
        llir::PPC64Register::R21, /* Local Variable */
        llir::PPC64Register::R22, /* Local Variable */
        llir::PPC64Register::R23, /* Local Variable */
        llir::PPC64Register::R24, /* Local Variable */
        llir::PPC64Register::R25, /* Local Variable */
        llir::PPC64Register::R26, /* Local Variable */
        llir::PPC64Register::R27, /* Local Variable */
        llir::PPC64Register::R28, /* Local Variable */
        llir::PPC64Register::R29, /* Local Variable */
        llir::PPC64Register::R30, /* Local Variable */
        llir::PPC64Register::R31, /* Local Variable */

        // FPRs
        llir::PPC64Register::F14, /* Local variable */
        llir::PPC64Register::F15, /* Local variable */
        llir::PPC64Register::F16, /* Local variable */
        llir::PPC64Register::F17, /* Local variable */
        llir::PPC64Register::F18, /* Local variable */
        llir::PPC64Register::F19, /* Local variable */
        llir::PPC64Register::F20, /* Local variable */
        llir::PPC64Register::F21, /* Local variable */
        llir::PPC64Register::F22, /* Local variable */
        llir::PPC64Register::F23, /* Local variable */
        llir::PPC64Register::F24, /* Local variable */
        llir::PPC64Register::F25, /* Local variable */
        llir::PPC64Register::F26, /* Local variable */
        llir::PPC64Register::F27, /* Local variable */
        llir::PPC64Register::F28, /* Local variable */
        llir::PPC64Register::F29, /* Local variable */
        llir::PPC64Register::F30, /* Local variable */
        llir::PPC64Register::F31, /* Local variable */
        llir::PPC64Register::FPSCR,

        // VRs
        llir::PPC64Register::VR20, /* Local variable */
        llir::PPC64Register::VR21, /* Local variable */
        llir::PPC64Register::VR22, /* Local variable */
        llir::PPC64Register::VR23, /* Local variable */
        llir::PPC64Register::VR24, /* Local variable */
        llir::PPC64Register::VR25, /* Local variable */
        llir::PPC64Register::VR26, /* Local variable */
        llir::PPC64Register::VR27, /* Local variable */
        llir::PPC64Register::VR28, /* Local variable */
        llir::PPC64Register::VR29, /* Local variable */
        llir::PPC64Register::VR30, /* Local variable */
        llir::PPC64Register::VSCR,
    };

    // Registers used to pass arguments and return values
    static constexpr llir::PPC64Register argument_regs[] = {
        llir::PPC64Register::R3,
        llir::PPC64Register::R4,
        llir::PPC64Register::R5,
        llir::PPC64Register::R6,
        llir::PPC64Register::R7,
        llir::PPC64Register::R8,
        llir::PPC64Register::R9,
        llir::PPC64Register::R10,
    };
};

template <typename ABI0, typename ABI1>
struct ABIComparator {
    static_assert(std::is_same_v<typename ABI0::RegisterT, typename ABI1::RegisterT>,
                  "Provided ABIs have different register types!");

    // An array containing the non-volatile registers specified in ABI0 but not ABI1
    static constexpr auto non_volatile_regs_difference = MAGIC_MAKE_DIFFERENCE_ARRAY(
                                                            ABI0::non_volatile_regs, ABI1::non_volatile_regs);
};

} // namespace ppc64le
} // namespace retrec

